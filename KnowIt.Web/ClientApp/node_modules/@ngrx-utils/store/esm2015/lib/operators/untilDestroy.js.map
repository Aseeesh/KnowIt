{"version":3,"file":"untilDestroy.js","sourceRoot":"ng://@ngrx-utils/store/","sources":["lib/operators/untilDestroy.ts"],"names":[],"mappings":";;;;;AAAA,OAAO,EAA4B,UAAU,EAAE,MAAM,MAAM,CAAC;AAC5D,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;;;;;AAK3C,MAAM,OAAO,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC;;;;;;AAM1C,MAAM,OAAO,YAAY;;;;;AAAG,CAC1B,SAAc,EACe,EAAE;;UACzB,cAAc,GAAG,SAAS,CAAC,WAAW;IAC5C,IAAI,cAAc,IAAI,IAAI,EAAE;QAC1B,yDAAyD;QACzD,6BAA6B;QAC7B,MAAM,IAAI,KAAK,CACb,yEAAyE,CAC1E,CAAC;KACH;IACD,IAAI,SAAS,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;QACrC,mCAAmC;QACnC,+BAA+B,CAAC,SAAS,CAAC,CAAC;KAC5C;IAED,iEAAiE;IACjE,OAAO,SAAS,CAAI,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;AAC3C,CAAC,CAAA;;;;;;AAKD,MAAM,UAAU,+BAA+B,CAAC,SAAc;IAC5D,SAAS,CAAC,QAAQ,CAAC,GAAG,IAAI,UAAU;;;;IAAO,CAAC,QAAQ,EAAE,EAAE;;;;cAGhD,cAAc,GAAG,SAAS,CAAC,WAAW;QAC5C,0BAA0B;QAC1B,SAAS,CAAC,WAAW;;;QAAG,GAAG,EAAE;YAC3B,kCAAkC;YAClC,QAAQ,CAAC,IAAI,EAAE,CAAC;YAChB,0BAA0B;YAC1B,QAAQ,CAAC,QAAQ,EAAE,CAAC;YACpB,yCAAyC;YACzC,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACjC,CAAC,CAAA,CAAC;QACF,2BAA2B;QAC3B;;;;QAAO,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC,EAAC;IACvD,CAAC,EAAC,CAAC;AACL,CAAC","sourcesContent":["import { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n// create a symbol identify the observable I add to\n// the component so it doesn't conflict with anything.\n// I need this so I'm able to add the desired behaviour to the component.\nexport const destroy$ = Symbol('destroy$');\n\n/**\n * An operator that takes until destroy it takes a components this a parameter\n * returns a pipeable RxJS operator.\n */\nexport const untilDestroy = <T>(\n  component: any\n): MonoTypeOperatorFunction<T> => {\n  const orignalDestroy = component.ngOnDestroy;\n  if (orignalDestroy == null) {\n    // Angular does not support dynamic added destroy methods\n    // so make sure there is one.\n    throw new Error(\n      'untilDestroy operator needs the component to have an ngOnDestroy method'\n    );\n  }\n  if (component[destroy$] === undefined) {\n    // only hookup each component once.\n    addDestroyObservableToComponent(component);\n  }\n\n  // pipe in the takeUntil destroy$ and return the source unaltered\n  return takeUntil<T>(component[destroy$]);\n};\n\n/**\n * @internal\n */\nexport function addDestroyObservableToComponent(component: any) {\n  component[destroy$] = new Observable<void>((observer) => {\n    // keep track of the original destroy function,\n    // the user might do something in there\n    const orignalDestroy = component.ngOnDestroy;\n    // replace the ngOndestroy\n    component.ngOnDestroy = () => {\n      // fire off the destroy observable\n      observer.next();\n      // complete the observable\n      observer.complete();\n      // and at last, call the original destroy\n      orignalDestroy.call(component);\n    };\n    // return cleanup function.\n    return (_: any) => (component[destroy$] = undefined);\n  });\n}\n"]}