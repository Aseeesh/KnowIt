/**
 * @fileoverview added by tsickle
 * Generated from: lib/operators/untilDestroy.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Observable } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
// create a symbol identify the observable I add to
// the component so it doesn't conflict with anything.
// I need this so I'm able to add the desired behaviour to the component.
/** @type {?} */
export const destroy$ = Symbol('destroy$');
/**
 * An operator that takes until destroy it takes a components this a parameter
 * returns a pipeable RxJS operator.
 * @type {?}
 */
export const untilDestroy = (/**
 * @template T
 * @param {?} component
 * @return {?}
 */
(component) => {
    /** @type {?} */
    const orignalDestroy = component.ngOnDestroy;
    if (orignalDestroy == null) {
        // Angular does not support dynamic added destroy methods
        // so make sure there is one.
        throw new Error('untilDestroy operator needs the component to have an ngOnDestroy method');
    }
    if (component[destroy$] === undefined) {
        // only hookup each component once.
        addDestroyObservableToComponent(component);
    }
    // pipe in the takeUntil destroy$ and return the source unaltered
    return takeUntil(component[destroy$]);
});
/**
 * \@internal
 * @param {?} component
 * @return {?}
 */
export function addDestroyObservableToComponent(component) {
    component[destroy$] = new Observable((/**
     * @param {?} observer
     * @return {?}
     */
    (observer) => {
        // keep track of the original destroy function,
        // the user might do something in there
        /** @type {?} */
        const orignalDestroy = component.ngOnDestroy;
        // replace the ngOndestroy
        component.ngOnDestroy = (/**
         * @return {?}
         */
        () => {
            // fire off the destroy observable
            observer.next();
            // complete the observable
            observer.complete();
            // and at last, call the original destroy
            orignalDestroy.call(component);
        });
        // return cleanup function.
        return (/**
         * @param {?} _
         * @return {?}
         */
        (_) => (component[destroy$] = undefined));
    }));
}
//# sourceMappingURL=untilDestroy.js.map